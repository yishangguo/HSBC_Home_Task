# Bank Transaction Management System

## Project Overview
This is a Spring Boot-based Bank Transaction Management System implemented in accordance with assignment requirements, providing comprehensive transaction management functionalities. The system utilizes an in-memory database for storage and supports caching mechanisms as well as concurrent operations.

## Technology Stack

### Backend
- **Java 17**: The latest LTS version
- **Spring Boot 3.2.0**: System framework
- **Spring Data JPA**: Data access layer
- **H2 Database**: In-memory database
- **Spring Cache**: Cache management
- **Maven**: Project management and build tool

### Frontend
- **HTML5**: Semantic markup
- **CSS3**: Styling
- **JavaScript ES6+**: Asynchronous operations and DOM manipulation
- **Responsive Design**: Mobile device adaptation
- **Intelligent Forms**: Dynamically show/hide fields based on business rules

### Deployment & Operations
- **Docker**: Containerized deployment
- **Kubernetes**: Cloud-native deployment
- **Health Checks**: Application monitoring
- **Auto-scaling**: Load management


## Architecture Design

### Design Philosophy
- **Layered Architecture**: Controller → Service → Repository with clear responsibilities
- **DTO Separation**: Different DTOs for creation and update to avoid validation conflicts
- **Immutable Design**: Critical business fields cannot be modified after creation to ensure data consistency
- **Auto-generation**: Transaction numbers and dates are handled automatically by the backend to reduce frontend errors
- **Cache Layering**: Multi-level caching strategy to improve query performance

### Layered Architecture
- **Interface Layer**: `controller` provides REST APIs, performs parameter validation and error mapping.
- **Service Layer**: `service` encapsulates business logic, idempotency validation, and transaction control, exposing stable interfaces.
- **Data Access Layer**: `repository` interacts with the database through Spring Data JPA, serving as a unified query entry.
- **Models & DTOs**: `model` for persistent objects, `dto` for input/output decoupling to avoid exposing internal structures.

### Robustness Design
- **Input Validation**: The service layer validates mandatory fields, amount ranges, time windows, and type legality; the controller layer performs basic validation and returns error results.
- **Exception Management**: Unified exception handling via `GlobalExceptionHandler` to standardize error responses and prevent exception penetration.
- **Idempotency Guarantee**: Uses `reference` as the business idempotency key and performs deduplication validation before insertion. The `reference` is automatically generated by the backend (format: `TXNyyyyMMddHHmmssSSSNNNN`) and no longer needs to be input by the frontend; `transactionDate` defaults to the current time.
- **Transaction Consistency**: Declarative transactions in the service layer, with automatic rollback for write operation failures; read operations use read-only transactions by default, with extensible policies.

### Immutable Fields & Update Strategy
- Immutable after creation: `reference` (transaction number), `accountNumber`, `amount`, `type`, `transactionDate`.
- Updatable only: `description`, `notes`.
- The update interface uses `UpdateTransactionRequest` (containing only `description` and `notes`) to avoid validation and updates of irrelevant fields.

### Caching & Performance
- **Cache Layering**: Uses Spring Cache with `ConcurrentMapCacheManager`, featuring the following cache namespaces:
  - `transactions`: Cache for single-transaction queries and paginated queries
  - `recentTransactions`: Cache for recent transaction lists
  - `accountBalances`: Cache for account balances and counts
  - `metadata`: Cache for metadata (e.g., transaction types)
- **Caching Strategy**: Uses `@Cacheable` for queries with more reads than writes; uniformly uses `@CacheEvict(allEntries = true)` for modification operations to ensure visibility and consistency.
- **Pagination Optimization**: Applies pagination to full-list queries and conditional searches; includes pagination parameters in cache keys to avoid pressure from large result sets.
- **Bulk Operations/Search**: Provides keyword search and combined conditional queries for easy integration with full-text indexing in the future.

### Index Usage
- Create indexes for the following fields in the production database:
  - **Unique Index**: `reference`
  - **Regular Index**: `accountNumber`, `type`, `transactionDate`, `(amount)`
  - **Composite Index (Optional)**: `(accountNumber, transactionDate DESC)` to cover common scenarios of sorting by account and time
- For search fields (e.g., `description`), full-text search can be integrated on demand (e.g., PostgreSQL GIN/Trigram or external Elasticsearch).

### Concurrent Processing
- **Thread Pool**: Uses a thread pool with capacity matching the servlet container and database connection pool; implements rate limiting and timeout settings for external I/O downstream.
- **Transactions & Isolation Levels**: Read-write separation is extensible; aggregates hot-write operations and implements optimistic concurrency control (refer to the `reference` idempotency key).
- **Cache Hit**: Reduces database pressure through cache hits for metadata and hot reads; sets TTL appropriately (e.g., when switching to Caffeine/Redis).
- **Scalability**: Supports horizontal scaling of replicas in Kubernetes, with elastic scaling via readiness/liveness probes and HPA (Horizontal Pod Autoscaler).

## Testing Strategy & Coverage

### Unit Tests (Service/Repository)
- Cover business validations (null values, negative amounts, future times, invalid types).
- Cover idempotency and duplicate reference exceptions, as well as conflict validation for update paths.
- Cover pagination, search, and statistical logic; cover boundary values for balance calculation (empty and zero).
- Verify the correctness of the metadata interface `getTransactionTypes`.
- Test update constraints: only `description` and `notes` are mutable, while other fields remain unchanged; use `UpdateTransactionRequest` for updates.

### Integration Tests (Controller + DB + Cache)
- End-to-end scenarios: Create → Query → Update → Delete.
- Verify response structure and metadata for paginated and conditional queries.
- Standardize unified exception response format and HTTP status code conventions.
- Validate cache hit paths (observability assertions can be added later).
- Ensure the edit interface only validates fields in `UpdateTransactionRequest` and does not return 400 errors due to missing amount/type/account.

### Performance & Concurrency Tests
- Concurrent creation (ignoring expected failures from duplicate references), with throughput and latency statistics.
- Verify latency thresholds for bulk paginated retrieval.
- Enforce access latency requirements for hot cache hits (metadata and lists).

### Coverage Targets
- Statement/branch coverage ≥ 85%, core business paths ≥ 95%.
- PR Gate integration (optional): Jacoco + Maven failure threshold strategy.

## Future Expansion Plan (Roadmap)
- **Enhanced Monitoring and Alerts**: Integrate Micrometer + Prometheus + Grafana; establish dashboards and alerts for cache hit rate, slow queries, and error rate.
- **Cache Upgrade**: Smoothly migrate from local `ConcurrentMap` to `Caffeine` or `Redis`, adding TTL/max capacity and distributed consistency strategies.
- **Database Evolution**: Migrate from H2 to PostgreSQL/MySQL; supplement table structure indexes and migration scripts (Flyway/Liquibase).
- **Search Capabilities**: Enable full-text indexing for description fields or integrate Elasticsearch to support more complex filtering and aggregation.
- **Security and Compliance**: Add authentication/authorization (OAuth2/OpenID), audit logs, data masking, and encrypted storage.
- **Domain Boundaries**: Split into independent microservices for `Transactions`, `Accounts`, and `Reconciliation`, enabling eventual consistency via event-driven architecture (Kafka).
- **Resilience and Cost**: Optimize HPA policies, configure resource quotas, implement automated capacity testing, and support canary releases.

## Current Project Structure

```
hsbc/
├── src/
│   ├── main/java/com/hsbc/transaction/
│   │   ├── controller/          # REST API Controllers
│   │   ├── service/             # Business Logic Layer
│   │   ├── repository/          # Data Access Layer
│   │   ├── model/               # Data Models
│   │   ├── dto/                 # Data Transfer Objects
│   │   │   ├── TransactionRequest    # DTO for Transaction Creation
│   │   │   ├── UpdateTransactionRequest # DTO for Transaction Update
│   │   │   └── TransactionResponse    # DTO for Transaction Response
│   │   ├── exception/           # Exception Handling
│   │   └── config/              # Configuration Classes
│   ├── main/resources/          # Configuration Files and Static Resources
│   └── test/                    # Test Code
├── k8s/                         # Kubernetes Configurations
├── Dockerfile                   # Docker Image Configuration
├── docker-compose.yml           # Docker Compose Configuration
├── pom.xml                      # Maven Configuration
├── README.md                    # Project Documentation
├── start.sh                     # Startup Script
```


## Implemented Designs

### API Design 
- ✅ **RESTful API**: Adheres to REST design principles
- ✅ **Complete Endpoints**: Covers all CRUD operations
- ✅ **Advanced Query**: Multi-criteria combined query and search
- ✅ **Pagination Support**: Efficient pagination and sorting
- ✅ **Error Handling**: Unified exception handling mechanism

### Data Management
- ✅ **In-memory Database**: H2 database configuration and optimization
- ✅ **Data Models**: Complete entity design and relationships
- ✅ **Data Validation**: Comprehensive input validation and constraints
- ✅ **Data Initialization**: Automatic loading of test data
- ✅ **Immutable Constraints**: Critical business fields cannot be modified after creation

### Performance Optimization 
- ✅ **Caching Mechanism**: Spring Cache integration
  - Cache namespaces: transactions, recentTransactions, accountBalances, metadata
  - Intelligent Caching Strategy: More reads than writes, unified cleanup on changes
- ✅ **Pagination Query**: Database-level pagination optimization
- ✅ **Concurrent Processing**: Thread-safe service implementation
- ✅ **Stress Testing**: Complete performance test suite
- ✅ **Auto-generation**: Optimized transaction number generation algorithm to avoid conflicts

### Test Coverage
- ✅ **Unit Tests**: Comprehensive testing of the service layer
  - Covers business validation, idempotency, and update constraints
- ✅ **Integration Tests**: API endpoint testing
  - Covers end-to-end scenarios; edit interface only validates update DTO
- ✅ **Performance Tests**: Concurrency and stress tests
- ✅ **Test Configuration**: Independent test environment
- ✅ **Constraint Tests**: Validation of immutable field protection

### Containerized Deployment
- ✅ **Docker Support**: Complete Dockerfile
- ✅ **Docker Compose**: Local development environment
- ✅ **Kubernetes**: Production deployment configuration
- ✅ **Health Checks**: Application monitoring and self-healing

### Web Interface
- ✅ **Modern UI**: Responsive design and user-friendly interface
- ✅ **Complete Functions**: Web implementation of all API functions
- ✅ **User Experience**: Intuitive operation process
- ✅ **Multi-language Support**: Chinese interface and prompts
- ✅ **Intelligent Forms**: Hide auto-generated fields during creation, gray out immutable fields during editing


## Core Functions

### Transaction Management
- ✅ **Transaction Creation**: Comprehensive form validation and business logic
  - Transaction number auto-generated (format: `TXNyyyyMMddHHmmssSSSNNNN`)
  - Transaction date defaults to the current time
  - No need for the frontend to input transaction number or date
- ✅ **Transaction Query**: Supports multiple query methods (ID, reference number, etc.)
- ✅ **Transaction Modification**: Intelligent editing function, only allowing modification of description and notes
  - Immutable fields: Transaction Number, Account Number, Transaction Amount, Transaction Type, Transaction Date
  - Dedicated Update DTO: `UpdateTransactionRequest` to avoid validation of irrelevant fields
- ✅ **Transaction Deletion**: Secure deletion operation and confirmation mechanism
- ✅ **Transaction List**: Pagination display and sorting functions

Edit Constraints: After creation, only "Transaction Description and Notes" can be modified; fields such as "Transaction Number (Original Reference Number), Account Number, Transaction Amount, Transaction Type, and Transaction Date" cannot be modified.

### Advanced Query
- ✅ Query by account number
- ✅ Query by transaction type
- ✅ Query by date range
- ✅ Query by amount range
- ✅ Keyword search
- ✅ Multi-criteria combined query

### Account Management
- ✅ Account balance calculation
- ✅ Transaction statistics
- ✅ Account transaction history

### Performance Features
- ✅ Caching mechanism
- ✅ Pagination query
- ✅ Concurrent processing
- ✅ Stress test support

## Quick Start

### Prerequisites
- Java 17+
- Maven 3.6+

### One-click Startup
```bash
# Clone the project
git clone https://github.com/yishangguo/HSBC_Home_Task.git
cd hsbc

# Start the application
./start.sh
```

The application will start at `http://localhost:8080`

### Docker Deployment

1. **Build the image**
```bash
docker build -t transaction-management .
```

2. **Run the container**
```bash
docker run -p 8080:8080 transaction-management
```

3. **Use Docker Compose**
```bash
docker-compose up -d
```

### Kubernetes Deployment

1. **Apply deployment configuration**
```bash
kubectl apply -f k8s/deployment.yaml
```

2. **Check deployment status**
```bash
kubectl get pods
kubectl get services
```

### Access Addresses
- **Web Interface**: http://localhost:8080
- **API Documentation**: http://localhost:8080/api/v1/transactions
- **H2 Console**: http://localhost:8080/h2-console
- **Health Check**: http://localhost:8080/actuator/health

## API Documentation

### Basic Endpoints
- `POST /api/v1/transactions` - Create a transaction
- `GET /api/v1/transactions/{id}` - Get transaction details
- `PUT /api/v1/transactions/{id}` - Update a transaction (only description and notes can be modified)
- `DELETE /api/v1/transactions/{id}` - Delete a transaction

### Query Endpoints
- `GET /api/v1/transactions` - Get all transactions (with pagination)
- `GET /api/v1/transactions/account/{accountNumber}` - Query by account
- `GET /api/v1/transactions/type/{type}` - Query by type
- `GET /api/v1/transactions/search?keyword={keyword}` - Keyword search
- `GET /api/v1/transactions/criteria` - Multi-criteria query

### Statistics Endpoints
- `GET /api/v1/transactions/account/{accountNumber}/balance` - Get account balance
- `GET /api/v1/transactions/account/{accountNumber}/count` - Get transaction count
- `GET /api/v1/transactions/recent` - Get recent transactions

### Sample Requests

#### Create a Transaction
```bash
curl -X POST http://localhost:8080/api/v1/transactions \
  -H "Content-Type: application/json" \
  -d '{
    "accountNumber": "12345678",
    "amount": 1000.00,
    "type": "DEPOSIT",
    "description": "Initial deposit"
  }'
```
Notes:
- The transaction number `reference` is automatically generated by the backend (format: `TXNyyyyMMddHHmmssSSSNNNN`), no need for the frontend to pass it.
- The transaction date `transactionDate` defaults to the current time, no need for the frontend to pass it.

#### Query Transactions
```bash
curl http://localhost:8080/api/v1/transactions?page=0&size=10
```

## Testing

### Unit Tests
```bash
./mvnw test
```

### Integration Tests
```bash
./mvnw verify
```

### Performance Tests
```bash
./mvnw test -Dtest=TransactionPerformanceTest
```

## Configuration

### Application Configuration
Main configuration file: `src/main/resources/application.yml`

- Database configuration
- Cache configuration
- Log configuration
- Monitoring endpoints

### Environment Configurations
- `dev` - Development environment
- `test` - Test environment
- `docker` - Docker environment
- `kubernetes` - Kubernetes environment

## Monitoring

### Health Checks
- `GET /actuator/health` - Application health status
- `GET /actuator/info` - Application information
- `GET /actuator/metrics` - Performance metrics

### H2 Console
- Access: `http://localhost:8080/h2-console`
- JDBC URL: `jdbc:h2:mem:transactiondb`
- Username: `sa`
- Password: `password`

## Performance Features

### Caching Strategy
- Transaction query cache
- Account balance cache
- Recent transaction cache

### Pagination Optimization
- Supports sorting
- Configurable page size
- Performance-optimized pagination query

### Concurrent Processing
- Thread-safe service layer
- Database connection pool
- Transaction management



## Deployment

### Production Environment
1. Configure production database
2. Adjust JVM parameters
3. Configure monitoring and logs
4. Set up health checks

### Containerization
- Docker image optimization
- Multi-stage build
- Security configuration
- Resource limits

### Kubernetes
- Auto-scaling
- Health checks
- Resource management
- Service discovery

## Troubleshooting

### Common Issues
1. **Port Occupancy**: Modify the port configuration in `application.yml`
2. **Insufficient Memory**: Adjust JVM parameters or Docker resource limits
3. **Database Connection**: Check H2 database configuration

### Logs
- Application logs: `logs/application.log`
- Error logs: `logs/error.log`
- Performance logs: `logs/performance.log`


## Contact Information

- Project Maintainer: [EasonGuo]
- Email: [yishangguo@foxmail.com]
- Project Repository: [https://github.com/yishangguo/HSBC_Home_Task]

## Changelog

### v1.0.0 (2025-09-03)
- Initial version release
